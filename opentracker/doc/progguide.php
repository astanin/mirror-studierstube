<?php require "header.php"; ?>
    <h1>Programmers Guide</h1>
          <p>This guide gives pointers about extending OpenTracker. It describes the core 
    interfaces that hold the library together and how to use them to implement new 
    functionality in the form of additional nodes and modules.</p>
    <h2>Introduction</h2><p>OpenTracker's functionality is provided by nodes that describe sources, transformations 
    and sinks of tracking data. Nodes are in turn supported by modules that implement 
    any special functions such as device drivers, computations and network code. 
    Extending OpenTracker is achieved by implemented such nodes and modules. The 
    blue words are names from source objects, such as classes, methods, members 
    and functions. Details can be found in the source documentation, generated by 
    doxygen.</p><h2>Tracking Data</h2><p>Tracking data is stored in objects of class <span class="name">State</span>. 
    It represents the a full state of a tracked object at a certain point in time. 
    This is a simple data structure type object with some convenience methods. It 
    is passed between nodes via the different interfaces defined by them. Currently 
    it can store the following data :</p><dl> 
    <dt><span class="name">position</span></dt>
    <dd><span class="name"></span>an array of 3 floats encoding the position in 
      x, y, z.</dd>
    <dt><span class="name">orientation</span></dt>
    <dd><span class="name"></span>an array of 4 floats encoding the orientation 
      as a quaternion in the format x ,y ,z ,w.</dd>
    <dt><span class="name">button</span></dt>
    <dd><span class="name"></span>an unsigned int, storing button state in the indiviual 
      bits. LSB is button 1, etc...</dd>
    <dt><span class="name">confidence</span></dt>
    <dd><span class="name"></span>a float encoding a value between 0 and 1 to represent 
      a confidence value in the state's data.</dd>
    <dt><span class="name">time</span></dt>
    <dd><span class="name"></span>a double representing the timestamp of the state, 
      in milliseconds from 1.1.1970.</dd>
</dl><p>Any part of the library ( such as a source node ) may only use or create a 
    subset of this data. In this case the values should be set to reasonable default 
    values (e.g. 0,0,0,1 for the orientation). <i>The <span class="name">time</span> 
    value is mandatory and must be set on all created states correctly !</i> To 
    simplify the handling of states some utility functions are available :</p><dl> 
    <dt><span class="name">State::State()</span></dt>
    <dd>copy constructor, copies the values of the passed state into the new State 
      object.</dd>
    <dt><span class="name">=operator()</span></dt>
    <dd> overloaded operator to set values of one state to anothers' state.</dd>
    <dt><span class="name">State::timestamp()</span></dt>
    <dd> sets the time value to the current system time, useful for source nodes, 
      creating new events.</dd>
    <dt><span class="name">State::null</span></dt>
    <dd> a static null state, used to compare against return values of functions 
      to provide a typesafe null object.</dd>
</dl><h2>Nodes and Interfaces</h2><p>Nodes are connected by edges in the data flow graph. There are different types 
    of edges and accordingly nodes have to implement different interfaces to be 
    connectable with other nodes via certain types of edges. The following three 
    edge types and interfaces are possible :</p><ul>
    <li><span class="name">EventGenerator</span> classic event passing interface, 
      working from children nodes up to parent nodes. A child node creates a new 
      event and its parent node is automatically notified of the event. The type 
      of an event is of class <span class="name">State</span>.</li>
    <li><span class="name">EventQueue</span> allows access to a queue of events, 
      ordered by their timestamps, with the latest event coming first, at slot 0. 
      This works from parents to children, i.e. parents query their children for 
      a certain event in the queue.</li>
    <li><span class="name">TimeDependend</span> allows access to a continous function 
      of states in time. It also works from parents to children, i.e. a parent queries 
      a child for the state at a given point in time.</li>
</ul><p>Note that state objects returned by the various functions of these interfaces 
    must not be changed ! Any node has to make a copy and change that to perform 
    any computations etc.</p><p>The type restrictions are typically enforced in the DTD of the XML configuration 
    files. Therefore wrong combinations at runtime are not possible. There are some 
    exceptions, however. The <span class="element">Ref</span> element can be used 
    as a child of any parent element and therefore it is possible to link nodes 
    supporting different interfaces with each other. It also allows to create loops 
    in the event processing, which are not caught and result in infinite loops ! 
    Therefore <span class="name">RefNodes</span> should be used with care.</p><p>A node can be queried at runtime whether it supports on of the three interfaces. 
    The three methods isEventGenerator(), isEventQueue() and isTimeDependend() return 
    either 0 or 1 corresponding to the node's support. This can be used to check 
    correct typing at runtime. Moreover new nodes derived from Node have to overload 
    the member functions and return the correct values to show that they support 
    a certain interface.</p><h4>EventGenerator</h4><dl> 
    <dt class="name">Node::isEventGenerator()</dt>
    <dd>Test method to check at runtime, whether a node supports the EventGenerator 
      interface. This shoud be overriden by deriving nodes and implemented to return 
      1, if the node implements the interface.</dd>
    <dt class="name">Node::updateObservers()</dt>
    <dd>When a node has generated a new event by creating new data and setting a 
      <span class="name">State</span> object to the data, it notifies its parent 
      and any RefNodes referencing it using this method. The implementation checks 
      whether the node is really an EventGenerator via <span class="name">Node::isEventGenerator()</span>, 
      so any nodes making use of this method, have to override the former too.</dd>
</dl><p>The following method is not part of the EventGenerator interface put closely 
    related. </p><dl> 
    <dt class="name">Node::onEventGenerated()</dt>
    <dd>Whenever a child generates a new event, it notifies its parent and any RefNodes 
      referencing it about a new event generated (hence the name). In this case 
      this method is called on the parent node to notify it of the new event. It 
      is therefore not really part of the EventGenerator interface, but used for 
      observers of this interface.</dd>
</dl><h4>EventQueue</h4><dl> 
    <dt class="name"> Node::isEventQueue()</dt>
    <dd>Test method to check at runtime, whether a node supports the EventQueue 
      interface. This shoud be overriden by deriving nodes and implemented to return 
      1, if the node implements the interface.</dd>
    <dt class="name">Node::getSize()</dt>
    <dd>returns the number of events currently stored in the queue. </dd>
    <dt class="name">Node::getEvent()</dt>
    <dd>returns a certain event, by number. The default parameter is 0, which returns 
      the last (i.e. newest) event. If the index is out of range the typesafe <span class="name">State::null</span> 
      reference is returned.</dd>
    <dt class="name">Node::getEventNearTime()</dt>
    <dd>returns the event that is closest to a certain point in time, the point 
      in time being the parameter of the method.<br>
    </dd>
</dl><h4>TimeDependend</h4><dl> 
    <dt class="name">Node::isTimeDependend()</dt>
    <dd>Test method to check at runtime, whether a node supports the TimeDependend 
      interface. This shoud be overriden by deriving nodes and implemented to return 
      1, if the node implements the interface.</dd>
    <dt class="name">Node::getStateAtTime()</dt>
    <dd>returns a <span class="name">State</span> object, representing the value 
      of the node at a given point in time, being the parameter of this method. 
      The states timestamp should have the same value as the requested time.</dd>
</dl><h3>Children, Parents and Trees</h3><p>The data flow graphs in OpenTracker are directed trees (or woods) with a single 
    root node. Therefore each node besides the root node has one parent, and may 
    have one or more children. A special type of node ( RefNode ) can be used to 
    relax this constraint and add additional edges between nodes. Moreover children 
    can be marked, to distinugish between different children. To access its parent 
    and children the Node class (superclass of all nodes) implements the following 
    API :</p><dl> 
    <dt class="name">Node::countChildren()</dt>
    <dd>returns the number of direct children, that is children not contained in 
      a wrapper element to mark them. </dd>
    <dt class="name">Node::getChild()</dt>
    <dd>takes an integer between 0 and the value returned by <span class="name">Node::countChildren()</span>-1 
      and returns a pointer to the indicated child. The children appear in the order 
      they are defined in the configuration file.</dd>
    <dt class="name">Node::countWrappedChildren()</dt>
    <dd>takes a string containing the name of a wrapper element and returns the 
      number of children containted in the specified wrapper element.</dd>
    <dt class="name">Node::getWrappedChild()</dt>
    <dd>takes a string specifying the wrapper element and an integer indicating 
      the wrapped child. It works like <span class="name">Node::getChild()</span> 
      but for a certain wrapper.</dd>
    <dt class="name">Node::isWrapperNode()</dt>
    <dd>returns whether the node is a wrapper node or not. This is interesting for 
      <span class="name">Node::onEventGenerated()</span>, where the wrapper node 
      will appear as the originating node and not a wrapped node. This way events 
      from different inputs can be distringuished.</dd>
    <dt class="name">WrapperNode::getTagName()</dt>
    <dd> returns the tag name (element name) of a wrapper node, indicating which 
      input it corresponds to. Within <span class="name">Node::onEventGenerated()</span>, 
      typical code to distinguish between different inputs looks something like 
      this :      </dd>
    </dl>
    <dl>
      <dd>
        <div class="fragment"><pre>if( generator.isWrapperNode() == 1 )  // this should always be the case
{
	WrapperNode &amp; wrap = (WrapperNode &amp;)generator;
	if( wrap.getTagName().compare(&quot;Input1&quot;) == 0 )
	{
		// ... do something specific for Input1
	}
	else if( wrap.getTagName().compare(&quot;Input2&quot;) == 0 )
	{
		// ... do something specific for Input2
	}
}</pre>
          </div>
      </dd>
    </dl>
    <h3>The Life of a Node</h3><h2>Modules</h2><p>A module is the basic element of functionality in the OpenTracker framework. 
    It implements anything that is needed by the application. All module classes 
    are derived from <span class="name">Module</span>. They override several of 
    the virtual methods according to their needs.</p><h3>The Life of a Module</h3><p>A module is going throught several steps during a program run. First it is 
    instantiated at some point, usually during initialisation. The global function 
    <span class="name">initializeContext()</span> is such a point, it instantiates 
    all known modules and adds them to a <span class="name">Context</span> object.</p><p>In the next step the modules <span class="name">Module::init()</span> method 
    is called. The parameters are data from the configuration section of the configuration 
    file. They are a <span class="name">StringTable</span> containing the attributes 
    of the configuration element and any subtrees of children nodes, stored in <span class="name">ConfigNode</span> 
    objects.</p><p>After parsing of the configuration file is finished and the DAG structure of 
    nodes has been built, the method <span class="name">Module::start()</span> is 
    called on all modules. This is a good place for any initialisations that depend 
    on configuration parameters and instantiated nodes.</p><p>Now the main loop is entered and for all modules the methods <span class="name">Module::pushState()</span>, 
    <span class="name">Module::pullState()</span> and <span class="name">Module::stop()</span> 
    are called. The first allows the generation of new state update events and introduction 
    into the tree via EventGenerator nodes. The second is to retrieve states from 
    the shared DAG structure via other interfaces such as the EventQueue or TimeDependend 
    interface. </p><p><span class="name">Module::stop()</span> tests whether a module wants to exit 
    the main loop and stop the program. If so the main loop is stopped and <span class="name">Module::close()</span> 
    is called on all modules. Then the program exits.</p><h3>Implementing a Module</h3><p>To implement a new module, decide about what your module will do in each of 
    these phases and which methods you need to override. Then derive your module 
    from the class <span class="name">Module</span> and you are done. To use in 
    the standard contexts, instantiate a module of your class in <span class="name">initializeContext()</span> 
    and add it to the context passed to the method. Then your module is available 
    to the simple standalone program.</p><h3>A multi-threaded Module</h3><p>If your module has some tasks that require more time than the event loop should 
    take, you are advised to implement your extension using multiple threads. A 
    simple helper class is <span class="name">ThreadModule</span> that takes care 
    of starting an additional worker thread for your module and provides synchronisation 
    methods. Override the <span class="name">ThreadModule::run()</span> method and 
    implement your tasks. Then use <span class="name">ThreadModule::lock()</span> 
    and <span class="name">ThreadModule::unlock()</span> to synchronize access to 
    your data between the work thread and the main loop calling <span class="name">pushState()</span> 
    or <span class="name">pullState()</span>.</p><h2> The NodeFactory, Module and Context Triangle</h2><p>The three classes typically are in a close relation. The <span class="name">NodeFactory</span> 
    is an interface that allows a parser to create nodes for elements by delegating 
    the actuall parsing of element names and attributes to the <span class="name">NodeFactory</span> 
    that knows about the node.</p><p>Because the <span class="name">NodeFactory</span> is the place a node is created, 
    it is simple to keep track of new nodes by implementing the <span class="name">NodeFactory</span> 
    in the same class as the <span class="name">Module</span>. This way a module 
    can very easily find out about the nodes it is interested in.</p><p>A <span class="name">Context</span> pulls all the different functionality together. 
    It contains a <span class="name">ConfigurationParser</span> object and stores 
    the modules and nodefactories needed for the application. Furthermore it implements 
    the main loop. The global helper function <span class="name">initializeContext()</span> 
    keeps the <span class="name">Context</span> class general by keeping the actual 
    module instantiations outside of the class.</p><h2>Examples</h2><p>A good starting point for your own modules and nodes are the following source 
    files :</p><ul>
    <li><span class="filename">TestModule.{h|cxx}</span> and <span class="filename">TestSource.{h|cxx}</span> 
      in <span class="filename">src/core</span>. These implement a very simple module 
      that creates source nodes firing events in regular interval.</li>
    <li><span class="filename">SelectionNode.{h|cxx}</span> in <span class="filename">src/common</span>. 
      A simple intermediate node with wrapper elements.</li>
    <li><span class="filename">TimeModule.{h|cxx}</span> in <span class="filename">src/common</span>. 
      A simple module that is not dealing with nodes. </li>
</ul>


<?php require "../footer.php"; ?>

</body></html>
